@require: list
@import: ref
@import: error

% # Polyfill for mutable array structure
% The current implementation is based on singly-linked lists and is very slow.
% The following code should be replaced with a more efficient implementation when
% the runtime support is ready.

module Array : sig
  type 'a t
  val length : 'a t -> int
  val nth : int -> 'a t -> ('a Ref.t) option
  val get : int -> 'a t -> 'a
  val set : int -> 'a -> 'a t -> unit
  val make : int -> 'a -> 'a t
  val init : (int -> 'a) -> int -> 'a t
  val append : 'a t -> 'a t -> 'a t
  val concat : ('a t) list -> 'a t
%  val sub : 'a t -> int -> int -> 'a t
  val to-list : 'a t -> 'a list
  val of-list : 'a list -> 'a t
  val map : ('a -> 'b) -> 'a t -> 'b t
end = struct
% type 'a t = ('a Ref.t) list
  type 'a b = 'a Ref.t
  type 'a t =
    | Nil
    | Cons of ('a b) * ('a t)
  let-rec length a = match a with
  | Nil -> 0
  | Cons (_, a) -> 1 + length a
  let-rec nth i a = match (a, i) with
  | (Nil, _) -> None
  | (Cons (r, _), 0) -> Some r
  | (Cons (_, a), i) -> nth (i - 1) a
  let get i a = match nth i a with
  | None -> Error.error `array: index out of range`
  | Some r -> Ref.get r
  let set i v a = match nth i a with
  | None -> Error.error `array: index out of range`
  | Some r -> Ref.set r v
  let make n v =
    let-rec go i acc = if i == n then acc else go (i + 1) (Cons (Ref.make v, acc)) in
    go 0 Nil
  let init f n =
    let-rec go i = if i == n then Nil else let v = f i in Cons (Ref.make v, go (i + 1)) in
    go 0
  let-rec append a1 a2 = match a1 with
  | Nil -> a2
  | Cons (r, a1) -> Cons (r, append a1 a2)
  let-rec concat xs = match xs with
  | [] -> Nil
  | x :: xs -> append x (concat xs)
  let-rec to-list a = match a with
  | Nil -> []
  | Cons (r, a) -> Ref.get r :: to-list a
  let-rec of-list l = match l with
  | [] -> Nil
  | x :: xs -> Cons (Ref.make x, of-list xs)
  let-rec map f a = match a with
  | Nil -> Nil
  | Cons (r, a) -> Cons (Ref.make (f (Ref.get r)), map f a)
end