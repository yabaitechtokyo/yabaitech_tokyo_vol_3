@import: ../book-class
@import: ../lib/typeset/code2

module Pohe : sig
  val article : block-text
end = struct

let bibliography = [
    (`l4`, Article(|
        author = {| Jochen Liedtke |};
        title = {Improving IPC by kernel design};
        journal = {14th ACM Symposium on Operating System Principles};
        volume = None;
        number = None;
        pages = (175, 188);
        year = 1993;
    |));
    (`l4_wikipedia`, WebSite(|
        author = {| ウィキペディアの執筆者 |};
        title = {L4マイクロカーネルファミリー};
        url = `https://ja.wikipedia.org/wiki/L4マイクロカーネルファミリー`;
        year = 2019;
    |));
    (`philipps`, WebSite(|
        author = {| Philipp Oppermann |};
        title = {Writing an OS in Rust };
        url = `https://os.phil-opp.com`;
        year = 2019;
    |));
    (`multiboot1`, WebSite(|
        author = {| Free Software Foundation, Inc. |};
        title = {Multiboot Specification version 0.6.96};
        url = `https://www.gnu.org/software/grub/manual/multiboot/multiboot.html`;
        year = 2010;
    |));
    (`multiboot2`, WebSite(|
        author = {| Free Software Foundation, Inc. |};
        title = {https://www.gnu.org/software/grub/manual/multiboot2/multiboot.html};
        url = `https://www.gnu.org/software/grub/manual/multiboot2/multiboot.html`;
        year = 2016;
    |));
]

let article = '<
    +chapter ?:(`pohe-article`)
    (|
        bibliography = bibliography;
        title = {Writing a (micro)kernel in Rust in 12 days - 2.5th day -};
        author = {nullpo-head};
    |)
    <
+section {前回までのあらすじ} <

+p{

久しぶり！今回のYabaiTech Tokyoでも、前号の続きとしてRustでのマイクロカーネル開発をやっていこう。
この連載は、私がRustでマイクロカーネルを開発する開発のログを、皆さんと共有するためのものだ。
その過程で、Rustによるカーネル開発の最高な点や厄介な点を、皆さんにご紹介していきたい。
そして、全ての開発が終わった暁には、たった12日間でRustでカーネルを実装するための、ちょうどいいチュートリアルができあがっている（はず）だろう。
前号では、12日間のうちの最初の一日目として、マイクロカーネルの歴史とL4カーネルについて説明し、
L4Ka::Pistachioカーネルをコンパイルして起動させてみたのだった。
さらに、二日目では、Phillipp氏の"Writing an OS in Rust"\cite[`philipps`];に従って、
Rustで小さなカーネル（と呼ぶことにしたベアメタルプログラム)を実装して、Qemuで動かした。
このときPhilipp氏の\code(`bootloader`); crateを用いてブートを実現したのだが、
これが後々マイクロカーネルを作るにあたって不都合になってしまう。
そこで、Multiboot規格\cite[`multiboot2`];に沿ったブート方式にカーネルを書き直す必要があった。
しかし、その部分で前回の連載は終了となってしまったのだった。なので今回は、この"2.5th day"を完成させていく記事になる。

}
+p{

2.5日目に早速進む前に、少しマイクロカーネルの歴史とL4カーネルについて振り返ってみよう。
Machに代表されるような伝統的なマイクロカーネルは、IPCのパフォーマンスに悪さに悩まされていた。
マイクロカーネルでは、システムコールがサーバー間の複数のIPCで実装され、そしてIPCはコンテキストスイッチを伴う。
一方、モノリシックカーネルのシステムコールは通常1回のコンテキストスイッチで済むから、
比較するとマイクロカーネルではシステムコールのコストが割高になってしまう。
そこで、Jochen Liedtke先生が最初に実装したL4マイクロカーネルファミリーは、
「極小性」をキーコンセプトとしてカーネルを再設計しなおし、パフォーマンスの高速化を図った。
IPCの機構はMachに比べて極端に単純になり、IPCのメッセージサイズはCPUのキャッシュに乗るよう再設計された。
プロセスのスケジューリングも単純化され、IPCを高速化するいくつかの工夫も導入された。
さらに初期のカーネルにいたってはすべてアセンブリで書いてしまうという執念の入りようで、ありうる極小のマイクロカーネルを完成させた。
その結果として、L4のIPCはMachに比べて20倍も高速化したのだった。\cite[`l4`];\cite[`l4_wikipedia`];

}
+p{

そして、L4の極小性は短期間でカーネルを自作してみるのにぴったりな性質だ！
今回実装ターゲットにしたL4 X.2 Standardでは、定義されているシステムコールが12個しかない。
この連載が、12日でカーネルを作る、と言い張っているのは、APIが12個しかない、というこの事実をあてにしているからだ。
いま"Standard"と書いたように、L4ファミリーにはL4カーネルが実装しているべきシステムコールやそのABI、割り込みハンドリングの規約などを定めた標準仕様が存在する。
これはちょうど、普段慣れ親しんでいるPOSIX規約のカーネル版、とでもいえるものだ。
これに準拠したカーネルを作れば、少ない修正でL4カーネル用のユーザーランドを動かせるようになるというわけ。
1日目でビルドしてみたPistachioカーネルは、このL4 X.2 Standardに準拠したL4カーネルだった。

具体的には、12個のシステムコールのリストは次の通り。

\enumerate {
    * \code(`KERNELINTERFACE`);
    * \code(`EXCHANGEREGISTERS`);
    * \code(`THREADCONTROL`);
    * \code(`SYSTEMCLOCK`);
    * \code(`THREADSWITCH`);
    * \code(`SCHEDULE`);
    * \code(`IPC`);
    * \code(`LIPC`);
    * \code(`UNMAP`);
    * \code(`SPACECONTROL`);
    * \code(`PROCESSORCONTROL`);
    * \code(`MEMORYCONTROL`);
}
冗談抜きでこれで全部だ。実にシンプルで小さい。
このシステムコールさえ実装すれば、おおよそPistachioと互換のカーネルができあがることになる。
そしてそれこそがこの連載の最終ゴールだ！

}

>  % section

+section {2.5th Day: Minimal Kernel in Rust with Multiboot2} <

+subsection{前回まで} <

+p{

それでは2.5日目を始めよう。前号ではPhilipps'
\footnote{
  Philipp氏の"Writing an OS in Rust"のことを、この連載では"Philipp's"と呼んでいる
}
にしたがって、どこまでカーネルを実装していたのだろう？
GitHub上のコードで言えば、このコミットのものまでであった。(\code(`https://github.com/nullpo-head/Rusty-L4/commit/72f400d7029a0431f87af27f64fb40abb3ff68ee`);)
これは、Philipp'sの"VGA Text Mode"
\footnote{
  https://os.phil-opp.com/vga-text-mode
}
の章を終えたときの実装に相当する。これをビルドして、Qemuを使って出力されたバイナリファイルを起動すると、\ref-figure(`fig:println`);が表示される。

\figure ?:(`fig:println`)
  {前号での最終画面}
  <+image-frame{\insert-image(14cm)(`pohe/figures/println.JPG`);}>

このときは、VGAのメモリ領域に書き込んでメッセージを表示するようなFree StandingなELFファイルをRustで書いた。
そして、そのELFのブートはPhilipp氏の\code(`bootloader`); crateと\code(`bootimage`); crateにお任せしたのだった。
それにより、私は自分自身でブートローダーを書くことなく、Rustプログラムを書くだけでx86_64アーキテクチャのブートから、
Rustランタイムの初期化まで簡単に達成できたのだった。

}

>  % subsection

+subsection{Boot with Multiboot2} <

+subsubsection{Bootloader Crate and Multiboot2} <

+p{

さて、では、その続きに進むとしよう！
今回やることは、\code(`bootloader`);を使うことをやめて、Multibootを使ったブートへと実装を変えることだ。
なぜそんなことをする必要があるのだろう？その理由は2つある。

}
+p{

一つ目は、現状の\code(`bootloader`); crateが、マイクロカーネル構成と少し相性が悪いこと。
マイクロカーネルは、ブートローダーに複数のELFファイルをマップしてもらえた方が実装がシンプルで済む。
マイクロカーネルは、複数のユーザーランドで動くサーバー群があって初めてオペレーティングシステムとして動作するわけだけど、
マイクロカーネルのカーネル部分は非常にシンプルなため、ファイルシステムをパースしてELFファイルをロードするような能力はない。
だから、このままでは、マイクロカーネルはそもそもサーバー群をメモリに展開することができない。
このような問題を解決するのが、まさにMultibootのBoot Modules機能だ。
MultibootのBoot Modulesをサポートするブートローダーは、複数のELFファイルをブートイメージから取り出して、メモリ上に展開しておいてくれる。
そして、カーネルを起動する際に、マップされたELFの情報を所定の方法でカーネルに渡してくれる。
逆に\code(`bootloader`); crateにはまだブートモジュールの機能はないため、少し工夫をしないとマイクロカーネルを起動することができないのだ。

}
+p{

二つ目の理由は、L4Ka::Pistachioの資産をスムーズに流用するためだ。
Pistachioカーネルは、ちょうどいま説明した理由でMultibootを使ってブートするようになっている。
基本的に私は、
1. まずPistachioで動くサーバーを実装してPistachioで動作を確認 
2. その後そのサーバーが自分で実装したカーネルでも動作するようシステムコールを作りこむ
、という順番で実装を進めていく予定だ。
だから、Multibootで自分のカーネルもブートするようにしておけば、Pistachioと自分のカーネルの差し替えがスムーズになるので、テストに都合がいい。
この2つの理由から、Multibootへと移行していこうと思う。

}

>  % subsubsection


+subsubsection{Write Multiboot2 Header, Linker Script, and Makefile} <

+p{

さて、もし最初の節で紹介したGitHub上のコミットをcloneしてくださっていれば、現在のRusty L4
\footnote {
  前回、この連載で開発するRust製L4カーネルをそう名付けたのだった。
}
のディレクトリ構成は以下のようになるはずだ。前回の連載のコードをお手元にお持ちの方も、おおよそ似たような構成になっているだろう。

\d-code(`
  .
  ├── Cargo.lock
  ├── Cargo.toml
  ├── src
  │   ├── main.rs
  │   └── vga_buffer.rs
  └── x86_64-rusty_l4.json
`);

今回は、このコードに変更を加えていく。

}
+p{

今回は、しばらくRustの世界とお別れを告げることになる。
快適でモダンだったRustの世界から離れ、しばしアセンブリを地道に書いていくことになる。最終的なゴールは、アセンブリの世界からRustの世界へと舞い戻ることだ。
まず、初めに\code(`startup.S`);を加えよう。
今までは\code(`bootloader`); crateと\code(`bootimage`); crateに頼っていた、ブートからRustの関数にジャンプするまでの道のりを、このアセンブリファイルで置き換えることになる。
このファイルの先頭に早速書かなければならないのが、Multibootヘッダーだ。

\d-code(`
    .section .multiboot_header
    .balign  16
  _mb_header:
    .long 0xe85250d6			/* magic */
    .long 0x00000000			/* flags */
    .long _mb_header_end - _mb_header	/* header length */
    .long 0x100000000 - (0xe85250d6 + 0 + (_mb_header_end - _mb_header))
    .word 0x0
    .word 0x0
    .long 0x8
  _mb_header_end:
`);

Multibootの仕様に従ったカーネルを書くのは非常に簡単で、今書いたこの構造体が、カーネルイメージファイルの先頭32768バイトのどこかに、64bitアラインされた状態で埋め込まれているだけでいい。\cite[`multiboot2`];
もしカーネルイメージがELFフォーマットでない場合はもう少しメモリレイアウトに関する情報を書かなければならないが、
ELFフォーマットを使うなら、メモリレイアウトもELFをパースして勝手に読み取ってくれる。
上の構造体のフィールドに関する詳しい説明は、興味があれば仕様を参照してくれればわかるけど、基本は上のものをコピーして使いまわせばOKだ。
逆に気を付けなければいけないことは、Multibootのバージョンだ。
Multibootにはバージョン1とバージョン2があって、今まさに書いたのはバージョン2の方。
実は前号ではMultiboot1を使ったのだけれど、今回は2へと変更している。前号でビルドしたPistachioカーネルの方も、のちほどMultiboot2を使うように書き直そう。
どうしてバージョン2が必要かというと、ELF64ファイルのブートを簡単にできるからだ。バージョン1で64bit ELFをブートするのは困難が伴ってしまう。
そういう訳で、今回使うのはバージョン2の方になる。

}
+p{

次に、ブートされて最初に実行されるアセンブリを書いていこう。
Multiboot対応のブートローダーによってブートされたカーネルは、最初32bit Protectedモードでブートローダーから処理が回ってくる。
このとき、ページングは有効にされていない。
今から書くスタートアップスクリプトはこの状態から処理をはじめ、最終的にRustのエントリー関数を呼び出すことが目的だ。
それをやるまでのステップは次のようになる。
\enumerate {
  * 仮のスタックを用意する
  * Rustで本格的にメモリ管理を行うまでの間に使う、仮のメモリレイアウトでページングを有効にする。
  * 仮のGDTを用意する。
  * 64bitロングモードを有効化する。
  * Rustのエントリー関数へジャンプする
}
これを順番にやっていくことになる。
まずは仮のスタックを用意して、シリアルポートからデバッグ出力を行う関数を作って動作を確認することから始めよう。

\d-code(`
  ###
  # The multiboot entry point
  ###
    .text
    .globl _start
  .code32
  _start:
    cli
    cld
    movl $_mini_stack, %esp
  # Debug
    movb $'A', %al
    call _putc_serial
    hlt

  _putc_serial:
    movl %eax, %ecx
    movl $(0x3f8 + 5), %edx
  1:
    inb %dx, %al
    testb $0x20, %al
    jnz 2f
    nop
    jmp 1b
  2:
    movl %ecx, %eax
    movl $0x3f8, %edx
    outb %al, %dx
    ret

  ###
  # Stack
  ###
    .data
    .space	1 << 21
  _mini_stack:
`);

}

>  % subsubsection

>  % subsection

>  % section

> % chapter

>  % article

end
