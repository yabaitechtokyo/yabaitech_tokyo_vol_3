@require: itemize
@import: local

let lstar = '<+section{L\*アルゴリズム} <
            +dialog(
                [(None,{突然、指名手配中の殺人鬼が現れた!});
                 (Some({殺人鬼}), {「ぶっぽるぎゃるぴるぎゃっぽっぱぁぁぁぁぁーっ!});
                 (None,{殺人鬼は奇声を上げて…});
                 (None,{　});
                 (None,{　          });
                 (None,{　          });
                 (None,{Angluin 1987年 L\*を振り上げた!});
                 (None,{そして殺人鬼はジャンプして思いっきりそれを…});
                 (None,{　});
                 (None,{　          });
                 (None,{　          });
                 (None,{振り下ろした!});]);
+p {
  前節説明したIDアルゴリズムは正規言語${\Lg}を、live-completeな文字列集合${P}と所属性神託を用いて学習します。
  IDアルゴリズムは${P}がlive-completeであることを要請しますが、
  一方でIDアルゴリズムは${P}が大きくなると観察表が大きくなり必要な所属性神託の回数が増大するので、${P}を必要以上に大きくするのは良くありません。
  本節ではlive-completeな文字列集合${P}を実行時に生成するL\*アルゴリズム\cite([`journals/iandc/Angluin87`]);を説明します。
  L\*アルゴリズムは次の二つの質問を神託に聞くことを通して学習を行ないます。今回も現実的にこんなことがわかる神託をどうやって用意するのか、という問題はここでは考えません。
}
+p{
\listing{
* 所属性質問 (membership query): 文字列 ${\word \in \Word} を神託に与えて、${\word} が学習したい言語 ${\Lg\subseteq \Word} に含まれているか (${\word \in \Lg})を問う質問。
* 等価性質問 (equivalence query): DFA ${\A} を神託に与えて、${\Lgof{\A}} が学習したい言語 ${\Lg} と等しいかどうかを問う質問。${\Lgof{\A}\neq \Lg}である場合には反例 ${\word\in \Word}、つまり ${\word\in \Lgof{\A} \triangle \Lg} を充たす最短の文字列 ${\word} が返る。ここで${\triangle}は集合の対称差の記号である。
}
}
+p {
   本節も例として、 \ref-figure(`fig:mustHaveKBF`);のDFAが認識する${\Lg = \setsep{ a \in \set{\text!{K,B,F}}}{\text!{KBF を部分文字列として含む}}} を用います。
観察表が以下の条件を充たすとき、その観察表を\emph{閉じている (closed)}と言います。
\listing{
* 各${w'\in P'}について、${T\[w,\text!{-}\]=T\[w',\text!{-}\]}を充たす${w\in P}が存在する
* 各${w'\in P}、${a\in\alphabet}について、${w\cdot a\in P\cup P'}が成り立つ
}
}
+subsection{L\* アルゴリズム} <
+p {
  \figure ?:(`fig:LStarObservationTable1`){一番始めの観察表(左)と所属性神託を使って内容を埋めた観察表(右)}<
  +centering{\observationTable(
    [[{} ;{${\epsilon}} ;];
     [{${\epsilon}};];
     [{—————};{—————};];]);
\observationTable(
    [[{} ;{${\epsilon}} ;];
     [{${\epsilon}};{-};];
     [{—————};{—————};];
     [{K};{-};];
     [{B};{-};];
     [{F};{-};];]);
 }
>
  L\*アルゴリズムではまず始めに\ref-figure(`fig:LStarObservationTable1`);左の観察表から始めます。最初に空欄になっているセル${T\[\epsilon, \epsilon\]}を所属性質問を用いて埋め、同時に${P'}にK,B,Fを追加し、同様に埋めます (\ref-figure(`fig:LStarObservationTable1`);右) 。
}
+p {
   kokokara!!
  ここで\ref-figure(`fig:observationTable1`);の観察表が閉じているかを判定します。今回は任意の${w\in P}について、行aの行ベクトル${T\[\text!{a,-}\]}が行${w}の行ベクトル${T\[w,\text!{-}\]}と一致しないので閉じていません。そこで閉じていない原因の行aを${P}に追加します。このとき各${\setsep{\text!{a} \cdot a}{a \in \alphabet^\ast}}を添字とする列が${P}と${P'}のどちらにもに存在しない場合、その存在しない添字を${P'}に追加します (\ref-figure(`fig:observationTable2`);) 。
}
+p {
\figure ?:(`fig:observationTable2`){${\epsilon}、a、bについて埋めた後、閉じるまで操作を続けた観察表}<
+centering{
% \tabular(fun cellf multif empty -> [
% [
% cellf {} ;
% cellf {${\epsilon}} ;
% ];
% [
% cellf {${\epsilon}};
% cellf {T};
% ];
% [
% cellf {a};
% cellf {F};
% ];
% [
% cellf {—————};
% cellf {—————};
% ];
% [
% cellf {b};
% cellf {F};
% ];
% [
% cellf {aa};
% cellf {T};
% ];
% [
% cellf {ab};
% cellf {F};
% ];
%           ])(fun xs ys -> (
%               match (ys, List.reverse ys) with
%               | (y0 :: y1 :: _, ylast :: _) ->
%                   ( match (xs, List.reverse xs) with
%                     | (x0 :: x1 :: _, xlast :: _) ->
%                         let grlstY =
%                           [y0; ylast] |> List.map (fun y ->
%                             stroke 1pt Color.black (Gr.line (x0, y) (xlast, y)))
%                         in
%                         (stroke 0.5pt Color.black (Gr.line (x1, y0) (x1, ylast)))
%                           :: (stroke 0.5pt Color.black (Gr.line (x0, y1) (xlast, y1))) :: grlstY

%                     | _ -> []
%                   )
%               | _ -> []
%           ));
  
}
>
}
+p {
  今回は観察表が閉じました。観察表が閉じている場合、次のルールに従って観察表からDFAを生成することができます。
}
+p{
\listing{
* 各${w\in P}に対して、DFAの状態${q_w}を生成する
* DFAの初期状態は${q_{\epsilon}}とする
* DFAの受理状態は${T\[w,\epsilon\] = \mathrm{T}}となる状態${q_w}とする
* DFAの遷移関数${\mathrm{\Delta}\paren{q_w,a}}は、${w\cdot a\in P}の場合${\mathrm{\Delta}\paren{q_w,a}=q_{w\cdot a}}とし、そうでない場合${T\[w\cdot a,\text!{-}\] = T\[w',\text!{-}\]}を充たす${w'\in P}について、${\mathrm{\Delta}\paren{q_w,a}=q_{w'}}とする。
}
}
+p {

  \figure ?:(`fig:evenDFAStep1`){\ref-figure(`fig:observationTable2`);の観察表に対応するDFA${\mathcal{A}_1}}<
     +image-frame{\insert-pdf-image(7cm)(path-to-root ^ `figs/evenDFAStep1.pdf`)(1);}
  >
  例えば\ref-figure(`fig:observationTable2`);の観察表からは\ref-figure(`fig:evenDFAStep1`);のDFA、${\mathcal{A}_1}が生成されます。
}
+p {
  \figure ?:(`fig:observationTable3`){操作を更に続けた観察表}<
+centering{
% \tabular(fun cellf multif empty -> [
% [
% cellf {} ;
% cellf {${\epsilon}} ;
% cellf {a} ;
% ];
% [
% cellf {${\epsilon}};
% cellf {T};
% cellf {F};
% ];
% [
% cellf {a};
% cellf {F};
% cellf {T};
% ];
% [
% cellf {b};
% cellf {F};
% cellf {F};
% ];
% [
% cellf {————};
% cellf {————};
% cellf {—};
% ];
% [
% cellf {aa};
% cellf {T};
% cellf {F};
% ];
% [
% cellf {ab};
% cellf {F};
% cellf {F};
% ];
% [
% cellf {ba};
% cellf {F};
% cellf {F};
% ];
% [
% cellf {bb};
% cellf {T};
% cellf {F};
% ];
%           ])(fun xs ys -> (
%               match (ys, List.reverse ys) with
%               | (y0 :: y1 :: _, ylast :: _) ->
%                   ( match (xs, List.reverse xs) with
%                     | (x0 :: x1 :: _, xlast :: _) ->
%                         let grlstY =
%                           [y0; ylast] |> List.map (fun y ->
%                             stroke 1pt Color.black (Gr.line (x0, y) (xlast, y)))
%                         in
%                         (stroke 0.5pt Color.black (Gr.line (x1, y0) (x1, ylast)))
%                           :: (stroke 0.5pt Color.black (Gr.line (x0, y1) (xlast, y1))) :: grlstY

%                     | _ -> []
%                   )
%               | _ -> []
%           ));
  
}
+centering{
% \tabular(fun cellf multif empty -> [
% [
% cellf {} ;
% cellf {${\epsilon}} ;
% cellf {a} ;
% cellf {b} ;
% ];
% [
% cellf {${\epsilon}};
% cellf {T};
% cellf {F};
% cellf {F};
% ];
% [
% cellf {a};
% cellf {F};
% cellf {T};
% cellf {F};
% ];
% [
% cellf {b};
% cellf {F};
% cellf {F};
% cellf {T};
% ];
% [
% cellf {ab};
% cellf {F};
% cellf {F};
% cellf {F};
% ];
% [
% cellf {————};
% cellf {————};
% cellf {—};
% cellf {—};
% ];
% [
% cellf {aa};
% cellf {T};
% cellf {F};
% cellf {F};
% ];
% [
% cellf {ba};
% cellf {F};
% cellf {F};
% cellf {F};
% ];
% [
% cellf {bb};
% cellf {T};
% cellf {F};
% cellf {F};
% ];
% [
% cellf {aba};
% cellf {F};
% cellf {F};
% cellf {T};
% ];
% [
% cellf {abb};
% cellf {F};
% cellf {T};
% cellf {F};
% ];
%           ])(fun xs ys -> (
%               match (ys, List.reverse ys) with
%               | (y0 :: y1 :: _, ylast :: _) ->
%                   ( match (xs, List.reverse xs) with
%                     | (x0 :: x1 :: _, xlast :: _) ->
%                         let grlstY =
%                           [y0; ylast] |> List.map (fun y ->
%                             stroke 1pt Color.black (Gr.line (x0, y) (xlast, y)))
%                         in
%                         (stroke 0.5pt Color.black (Gr.line (x1, y0) (x1, ylast)))
%                           :: (stroke 0.5pt Color.black (Gr.line (x0, y1) (xlast, y1))) :: grlstY

%                     | _ -> []
%                   )
%               | _ -> []
%           ));
  
}
>
  DFAを一つ生成することができたので等価性質問によってこのDFA学習したい正規言語を認識するかどうかを調べてみます。
今回、DFA${\mathcal{A}_1}は言語${L}を認識しないので、最短の反例 ba が返ります。
次に反例 baがどの位置から\ref-figure(`fig:observationTable2`);の観察表と食い違ったかを見てみます。
今回は${T\[\text!{b,-}\]= T\[\text!{a,-}\]}で、実際${b\nin L}と${a\nin L}が成り立ちますが、${ba\nin L}、${aa \in L}となるので末尾のaで観察表と食い違いました。
これはつまり現在の状態の受理・非受理のみではなく、現在の状態からaを読んだときの受理・非受理も考慮する必要があるということになります。
これを表わすために${S}の列にaを加え、先と同様に観察表が閉じるまで所属性質問を繰り返します (\ref-figure(`fig:observationTable3`);) 。
}
%      page-break page pagecontf pagepartsf (bb-toc +++ bb-main)        
+p {  
  \ref-figure(`fig:observationTable3`);の下側の観察表から生成されるDFAについて等価性質問を問い合わせると学習したい言語と一致するので、今回の学習はここで終了となります。
ここまでの流れだけを見ると今回たまたま上手く行っただけで、この学習が有限回で停止しない場合もあるのではないかと疑問に思うと思われますが、実は常に有限回 (より正確には多項式回)で停止しますし、更にはこの方法で生成されるDFAは与えられた言語を認識するDFAのなかで状態数が最小となることもわかります。
これらの点について次に説明していきます。
}
+p {
  \figure ?:(`fig:evenDFAStep2`){\ref-figure(`fig:observationTable3`);の観察表に対応するDFA${\mathcal{A}_2}及び${\mathcal{A}_3}}<
     +image-frame{\insert-pdf-image(7cm)(path-to-root ^ `figs/evenDFAStep2.pdf`)(1);}
     +image-frame{\insert-pdf-image(7cm)(path-to-root ^ `figs/evenDFA.pdf`)(1);}
  >
}
>
+subsection{停止性} <
+p {
  さて、Myhill-Nerodeの定理の立場からL\*アルゴリズムの観察表を見ていきます。
まず、各${\word\in P}について行ベクトル${T\[w,\text!{-}\]}は互いに異なる、つまり適宜末尾に文字列を加えたときの受理/非受理の関係が異なるので、${P}の要素数は${\Lg/\MNRel{\Lg}}の要素数以下になり、${L}が正規言語であるとならば上限が存在します。
各${P'}の要素は${P}の要素に一文字付け加えたものであるので、${\abs{P'}\leq\abs{P}\times\abs{\alphabet}}となります。
また、${S}に添字${w'}を追加する際は${w'}を追加することで新たに食い違うような${w'}のみを追加する、つまり各${w\in S}について${T\[u,w\]=T\[u',w\]}であるが${T\[u,w'\]\neq T\[u',w'\]}である様な${u,u' \in P\cup P'}が存在するときのみ${w'}を${S}に追加します。
従って、${\abs{S}\leq \abs{\Lg/\MNRel{\Lg}}\times \paren{1+ \abs{\alphabet}}}も成立します。
更に観察表を閉じる際及び等価性質問の結果反例が返って来た際には${P}と${S}の大きさが1以上増えます。
以上よりL\*アルゴリズムは${\Lg}が正規言語であれば常に停止し、${\Lgof{\A}=\Lg}を充たすDFA${\A}を返することがわかります。
また、L\*アルゴリズムが生成するDFAの状態数は${\abs{P}}ですが、${L\paren{\A}=L}を充たす任意のDFAの状態数は${\Lg/\MNRel{\Lg}}以下であることから、${\A}は${\Lgof{\A}=\Lg}を充たす状態数が最小のDFAであることもわかります。
}
>
>>
