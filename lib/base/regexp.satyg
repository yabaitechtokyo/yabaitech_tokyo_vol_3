% based on https://swtch.com/~rsc/regexp/regexp2.html

@import: base
@import: string
@import: array
@import: debug
@import: option2
@require: list
@import: list2
@import: char

module RegExp : sig
  type t

  % concatenation and alternation
  val empty : t
  val seq : t -> t -> t
  val sequence : t list -> t
  val fail : t
  val alt : t -> t -> t
  val choice : t list -> t

  % quantifiers
  val many : t -> t
  val many1 : t -> t
  val opt : t -> t
  val many-ng : t -> t  % non-greedy Kleene star
  val many1-ng : t -> t
  val opt-ng : t -> t

  % submatching
  val group : t -> t
  %val ref : int -> t

  % anchors
  val bof : t  % beginning of file
  val eof : t
  val bol : t % beginning of line
  val eol : t

  % char classes
  val any : t
  val char : Char.t -> t
  val satisfy : (Char.t -> bool) -> t
  val oneof : string -> t
  val alpha : t
  val digit : t
  val space : t

  % compound patterns
  val string : string -> t
  val spaces : t
  val between : t -> t -> t -> t

  val test : t -> string -> bool
  val exec : t -> string -> ((int * string) option) list

  % for debug
  type vm-inst
  val compile : t -> vm-inst Array.t * int
  val print-iseq : vm-inst Array.t -> unit
end = struct

  type anchor = BOF | EOF | BOL | EOL | NOWHERE

  type vm-inst =
  | MATCH
  | CHAR of Char.t
  | JMP of int
  | SPLIT of int * int
  | ANY
  | STRING of string
  | SAVE of int
%  | REF of int   % backreference
  | ANCHOR of anchor
  | PRED of Char.t -> bool
  | REGEXP of regexp  % tests a character using built-in regexp; mainly for performance

  let run iseq ngroup s =
    let len = String.length s in
    let dp = Array.length iseq |> Array.init (fun _ -> Array.make (len + 1) None) in
    let memoize2 f i j =
      let dpi = dp |> Array.get i in
      match dpi |> Array.get j with
      | Some r -> r
      | None ->
        let () = dpi |> Array.set j (Some true) in   % avoid infinite loop e.g. (a*)*
        let r = f i j in
        let () = dpi |> Array.set j (Some r) in
        r in
    let trace = Array.make (2 * ngroup) None in
    let-rec loop pc sp =
      let main pc sp =
        match iseq |> Array.get pc with
        | MATCH -> true
        | CHAR c -> ~(&(sp < len) &&& &(Char.equal c (Char.at sp s)) &&& &(loop (pc + 1) (sp + 1)))
        | JMP l -> loop (pc + l) sp
        | SPLIT (l1, l2) -> ~(&(loop (pc + l1) sp) ||| &(loop (pc + l2) sp))
        | ANY -> if sp < len then loop (pc + 1) (sp + 1) else false
        | STRING c ->
          let l = String.length c in
          ~(&(sp + l <= len) &&& &(String.equal c (String.sub s sp l)) &&& &(loop (pc + 1) (sp + l)))
        | SAVE i ->
          let old = trace |> Array.get i in
          let () = trace |> Array.set i (Some sp) in
          if loop (pc + 1) sp then true else
          let () = trace |> Array.set i old in
          false
        % % The current implementation of REF instruction does not work well with memoize2.
        % % I leave this for future refactoring.
        % | REF i ->
        %   (match trace |> Array.get (2 * i + 1) with
        %   | None -> Error.error `unbound backreference`
        %   | Some(j) -> let (Some st) = trace |> Array.get (2 * i) in
        %     let c = String.sub s st (j - st) in
        %     let l = String.length c in
        %     if sp + l <= len then if String.equal c (String.sub s sp l) then loop (pc + 1) (sp + l) else false else false)
        | ANCHOR a ->
          ~(&(match a with
              | BOF -> sp == 0
              | EOF -> sp == String.length s
              | BOL -> ~(&(sp == 0) ||| &(Char.equal (Char.at (sp - 1) s) Char.newline))
              | EOL -> ~(&(sp == String.length s) ||| &(Char.equal (Char.at sp s) Char.newline))
              | NOWHERE -> false)
            &&& &(loop (pc + 1) sp))
        | PRED f ->
          ~(&(sp < len) &&& &(f (Char.at sp s)) &&& &(loop (pc + 1) (sp + 1)))
        | REGEXP re -> ~(&(sp < len) &&& &(string-match re (String.sub s sp 1)) &&& &(loop (pc + 1) (sp + 1))) in
      memoize2 main pc sp in
    let r = loop 0 0 in
    (r, trace)

  type pattern =
  | P-alt of pattern * pattern
  | P-seq of pattern * pattern
  | P-any
  | P-empty
  | P-string of string
  | P-char of Char.t
  | P-many of pattern
  | P-many1 of pattern
  | P-opt of pattern
  | P-many-ng of pattern
  | P-many1-ng of pattern
  | P-opt-ng of pattern
  | P-group of pattern
%  | P-ref of int
  | P-anchor of anchor
  | P-satisfy of Char.t -> bool
  | P-regexp of regexp

  type t = pattern

  let alt p1 p2 = P-alt (p1, p2)
  let seq p1 p2 = P-seq (p1, p2)
  let any = P-any
  let empty = P-empty
  let string c = P-string c
  let char c = P-char c
  let many p = P-many p
  let many1 p = P-many1 p
  let opt p = P-opt p
  let many-ng p = P-many-ng p
  let many1-ng p = P-many1-ng p
  let opt-ng p = P-opt-ng p
  let group p = P-group p
%  let ref i = P-ref i
  let bof = P-anchor (BOF)
  let eof = P-anchor (EOF)
  let bol = P-anchor (BOL)
  let eol = P-anchor (EOL)
  let fail = P-anchor (NOWHERE)
  let satisfy f = P-satisfy f

  let oneof s = % TODO: use regexp
    let s = String.to-list s in
    satisfy (fun c -> (Option2.is-some (List2.find (Char.equal c) s)))
  let alpha = P-regexp (regexp-of-string `[a-zA-Z]`)
  let digit = P-regexp (regexp-of-string `[0-9]`)
  let space = P-regexp (regexp-of-string (`[` ^ String.of-codepoints [9;10;11;12;13;32] ^ `]`))  % see https://stackoverflow.com/questions/39813584/how-to-split-on-whitespaces-in-ocaml
  let spaces = many1 space

  let between op cl p = seq op (seq p cl)
  let choice ts = List.fold-left alt fail ts
  let sequence ts = List.fold-right seq empty ts

  let compile p =
    let-mutable ngroup <- 0 in
    let-rec codegen p =
      let-mutable acc <- [] in
      let-mutable cnt <- 0 in
      let emit inst =
        let () = acc <- inst :: !acc in
        let () = cnt <- !cnt + 1 in
        () in
      let emit-chunk chunk =
        chunk |> List.fold-right (fun inst () -> emit inst) () in
      let-rec loop p = match p with
      | P-alt (p1, p2) ->
        let (chunk1, len1) = codegen p1 in
        let (chunk2, len2) = codegen p2 in
        let () = emit (SPLIT (1, len1 + 2)) in
        let () = emit-chunk chunk1 in
        let () = emit (JMP (len2 + 1)) in
        let () = emit-chunk chunk2 in
        ()
      | P-seq (p1, p2) ->
        let () = loop p1 in
        let () = loop p2 in
        ()
      | P-any ->
        emit ANY
      | P-empty ->
        ()
      | P-string c ->
        emit (STRING c)
      | P-char c ->
        emit (CHAR c)
      | P-many p ->
        let (chunk, len) = codegen p in
        let () = emit (SPLIT (1, len + 2)) in
        let () = emit-chunk chunk in
        let () = emit (JMP (- len - 1)) in
        ()
      | P-many1 p ->
        let c1 = !cnt in
        let () = loop p in
        let len = !cnt - c1 in
        let () = emit (SPLIT (-len, 1)) in
        ()
      | P-opt p ->
        let (chunk, len) = codegen p in
        let () = emit (SPLIT (1, len + 1)) in
        let () = emit-chunk chunk in
        ()
      | P-many-ng p ->
        let (chunk, len) = codegen p in
        let () = emit (SPLIT (len + 2, 1)) in
        let () = emit-chunk chunk in
        let () = emit (JMP (- len - 1)) in
        ()
      | P-many1-ng p ->
        let c1 = !cnt in
        let () = loop p in
        let len = !cnt - c1 in
        let () = emit (SPLIT (1, -len)) in
        ()
      | P-opt-ng p ->
        let (chunk, len) = codegen p in
        let () = emit (SPLIT (len + 1, 1)) in
        let () = emit-chunk chunk in
        ()
      | P-group p ->
        let i = !ngroup in
        let () = ngroup <- !ngroup + 1 in
        let () = emit (SAVE (2 * i)) in
        let () = loop p in
        let () = emit (SAVE (2 * i + 1)) in
        ()
%      | P-ref i ->
%        emit (REF i)
      | P-anchor a ->
        emit (ANCHOR a)
      | P-satisfy f ->
        emit (PRED f)
      | P-regexp re ->
        emit (REGEXP re) in
      let () = loop p in
      (!acc, !cnt) in
    let (chunk, _) = codegen p in
    let iseq = MATCH :: chunk |> List.reverse |> Array.of-list in
    (iseq, !ngroup)

  let test p s =
    let (iseq, ngroup) = compile (seq (many-ng any) (group p)) in
    let (r, _) = run iseq ngroup s in
    r

  let exec p s =
    let (iseq, ngroup) = compile (seq (many-ng any) (group p)) in
    let (_, trace) = run iseq ngroup s in
    let-rec subs i =
      if i == ngroup then []
      else match trace |> Array.get (2 * i + 1) with
      | None -> None :: subs (i + 1)
      | Some(e) ->
        let (Some st) = trace |> Array.get (2 * i) in
        Some (st, String.sub s st (e - st)) :: subs (i + 1) in
    subs 0

  let print-iseq iseq =
    let-rec loop i xs =
      match xs with
      | [] -> ()
      | x :: xs ->
        let inst = match x with
          | MATCH -> `MATCH`
          | ANY -> `ANY`
          | STRING s -> `STRING `# ^ s
          | CHAR c -> `CHAR `# ^ String.of-char c
          | JMP i -> `JMP `# ^ (String.of-int i)
          | SPLIT (i,j) -> `SPLIT `# ^ (String.of-int i) ^ #` `# ^ (String.of-int j)
          | SAVE i -> `SAVE `# ^ (String.of-int i)
%          | REF i -> `REF `# ^ (String.of-int i)
          | ANCHOR a ->
            `ANCHOR `# ^ (match a with
            | BOF -> `BOF`
            | EOF -> `EOF`
            | BOL -> `BOL`
            | EOL -> `EOL`
            | NOWHERE -> `NOWHERE`)
          | PRED f -> `PRED <function>`
          | REGEXP re -> `REGEXP <re>` in
        let () = Debug.log (String.of-int i ^ `: `# ^ inst) in
        loop (i + 1) xs in
    loop 0 (Array.to-list iseq)
end