% regexp engine based on NFA->DFA conversion

@require: list
@require: option
@import: string
@import: error

module RegExp2 : sig

  type t
  val or : t -> t -> t
  val seq : t -> t -> t
%   val any : t
  val empty : t
%   val string : string -> t
%   val group : t -> t
  val many : t -> t
  val many1 : t -> t
  val opt : t -> t

%   val matches : t -> string -> ((int * string) list) option
%   val test : t -> string -> bool

end = struct

  % type dfa = int * (int * string * int) list * int list

  let-rec any pred lst = match lst with
  | [] -> false
  | x :: xs -> pred x || any pred xs

  let member elt lst = any (fun x -> x == elt) lst

  let-rec find pred lst = match lst with
  | [] -> None
  | x :: xs -> if pred x then Some x else find pred xs

  let-rec dfa-matches (st, tr, ac) input =
    let accept s = member s ac in
    let next s c = let (Some (_,_,e)) = find (fun (ss,cc,ee) -> ss == s && String.equal cc c) tr in e in
    let-rec loop s input = match input with
    | [] -> accept s
    | c :: cs -> loop (next s c) cs in
    loop st (String.to-list input)

  type t =
    | Zero
    | Add of t * t
    | Mult of t * t
    | Star of t
    | Char of string

  let or p q = Add (p, q)
  let seq p q = Mult (p, q)
%   let any = N-dot
  let empty = Zero
%  let string s = List.foldr (fun ) s
%  let group p = N-paren p
  let many p = Star p
  let many1 p = seq p (many p)
  let opt p = or empty p

  let-rec to-nfa re =
    let-mutable state <- 0 in
    let new-state () =
      let s = !state in
      let () = state <- !state + 1 in
      s
    in
    match re with
    | Zero ->
      let s = new-state () in (s, [], [s])
    | Add (r1, r2) ->
      let (s1, t1, e1) = to-nfa r1 in
      let (s2, t2, e2) = to-nfa r2 in
      let s = new-state () in
      (s, List.concat [[(s, None, s1); (s, None, s2)]; t1; t2], List.append e1 e2)
    | Mult (r1, r2) -> 
      let (s1, t1, e1) = to-nfa r1 in
      let (s2, t2, e2) = to-nfa r2 in
      (s1, List.concat [List.map (fun e -> (e, None, s2)) e1; t1; t2], e2)
    | Star r1 ->
      let (s1, t1, e1) = to-nfa r1 in
      let s = new-state () in
      (s, List.concat [[(s, None, s1)]; List.map (fun e -> (e, None, s1)) e1; t1], s :: e1)
    | Char c ->
      let s = new-state () in
      let e = new-state () in
      (s, [(s, Some c, e)], [e])

  let-rec eps-closure tr ss =
    let-mutable seen <- [] in
    let-rec rec ss = match ss with
    | [] -> ()
    | s :: ss ->
      if member s !seen then () else
      let () = seen <- s :: !seen in
      let nexts =
        tr |> List.filter (fun (ss,cc,_) -> ss == s && (match cc with | None -> true | _ -> false))
           |> List.map (fun (_,_,ee) -> ee) in
      let () = rec nexts in
      rec ss in
    rec ss

  % let-rec eps-elim (st, tr, ac) =
  %   let fin = 
  %   let tr = tr |> List.filter (fun (s,c,e) -> (match c with | None -> false | Some v -> true))
  %               |> List.map (fun (s,Some c,e) -> (s,c,e)) in
  %   (st, tr, ac)
end