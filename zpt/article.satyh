@require: math
@import: ../book-class
@import: ../lib/typeset/derive

module Zpt : sig
  val article : block-text
end = struct

let-math \neg = math-char MathPrefix `¬`
let-math \lneg = math-char MathPrefix `∼`

let-math \iff = text-in-math MathRel (fun ctx -> inline-skip 5pt ++ read-inline ctx {iff} ++ inline-skip 5pt)
let-math \and = text-in-math MathRel (fun ctx -> inline-skip 5pt ++ read-inline ctx {and} ++ inline-skip 5pt)
let-math \or = text-in-math MathRel (fun ctx -> inline-skip 5pt ++ read-inline ctx {or} ++ inline-skip 5pt)
let-math \void = text-in-math MathOrd (fun ctx -> inline-nil)
let-math \tilde = ${\rightarrow}
let-math \ntilde = ${\nrightarrow}
let-math \L = text-in-math MathPrefix (fun ctx -> read-inline ctx {\emph{L}})

let-math \oarr obj = math-upper obj ${\rightarrow}

let-math \seq ant suc = ${#ant \vdash #suc}
let-math \biseq ant-true ant-false suc-true suc-false =
    ${#ant-true : #ant-false \vdash #suc-true : #suc-false }
let-math \nbiseq ant-true ant-false suc-true suc-false =
    ${#ant-true : #ant-false \nvdash #suc-true : #suc-false }

let-inline ctx \todo inner =
  let ctx-todo = ctx |> set-text-color Color.red in
  read-inline ctx-todo {[TODO: #inner;]}

let-inline ctx \quote inner =
    let font-ratio-cjk = 0.88 in
    let len = ((get-font-size ctx) *' font-ratio-cjk) *' 4. in
    let ib-inner = inline-skip len ++ read-inline ctx inner ++ inline-fil in
    let paragraph = form-paragraph ctx ib-inner in
    inline-fil ++ embed-block-breakable ctx paragraph

let bibliography = [
    (`LogicVSI`, Book(|
        author = {| Graham Priest |};
        title = {Logic: A Very Short Introduction};
        publisher = {Oxford University Press};
        year = 2017
    |));
    (`Belnap77`, Article(|
        author = {| Belnap N.D|};
        title = {A Useful Four-Valued Logic};
        journal = {Modern Uses of Multiple-Valued Logic};
        volume = Some(2);
        number = None;
        pages = (5, 37);
        year = 1977;
    |));
    (`Bochman98`, Article(|
        author = {| Alexander Bochman|};
        title = {Biconsequence Relations: A Four-Valued Formalism of Reasoning with Inconsistency and Incompleteness};
        journal = {Notre Dame Journal of Formal Logic};
        volume = Some(39);
        number = Some({1});
        pages = (47, 73);
        year = 1998;
    |));
    ]

let article =
    open Derive in
    '<
    +chapter ?:(`zpt-article`)
    (|
        bibliography = bibliography;
        title = {真矛盾主義入門};
        author = {zeptometer};
    |)
    <
        +p{今回の記事は割と純粋に論理学系の記事なんだ。テックのテの字もないけどvol.1からそうだった気がするしあまり気にしないでくれよな。}

        +section {導入} <
            +p{「矛盾」という言葉が中国の古典から来ていることはよく知られていますよね。「この盾はどんな攻撃も防ぐぞ」「この矛は全てのものを貫くんだ」なんて調子のいいことをぬかしていた商人が「じゃあその矛でその盾を突いたらどうなるんだ」と真っ当な指摘をされて何も言えなくなってしまったという話です。}
            +p{この話でもそうなんですが、思考や議論に矛盾を生じることを我々はよしとしません。結論が矛盾しているならそれを導く過程や前提のどこかが間違っていると考えるのです。無矛盾の原則とでも呼びましょうか、この考えは論理体系の形式化においても最も基本的なアイデアの一つになっています。}
            +p{しかしながらこの無矛盾の原則が必ずしも成り立たないと考える人たちがいます。彼らによると矛盾の中には「真なる矛盾」、つまり真でありかつ偽であるような命題が存在するというのです。このような立場を\dfn{真矛盾主義}(\dfn{dialetheism})と呼びます。この記事は真矛盾主義の動機付けやその形式化について紹介します。}
        >
        +p{\todo{背景の説明をもう少し書きたい。あと矛盾=真かつ偽であるみたいな説明入れといた方がいいよね多分}}
        +section {「何故」真矛盾主義か} <
            +p{"Logic: A very short introduction"\cite[`LogicVSI`];という論理学の入門書があります。この本のいい所は新しい論理を紹介する時に「自然言語にこういう推論や概念があって、これをうまく表現する論理体系が欲しい」という感じで何故そういう論理を考えたいのかという動機付けをわかりやすく説明してくれている点です。}
            +p{先程の章で「真でも偽でもあるような文が存在する」という主張を聞いた時に、最初に出る質問はきっと「何故そんなややこしい状況を考えたいのだろうか」でしょう。それに対する説明をいくつか紹介します。}

            +subsection {矛盾した法律} <
                +p{一つ目の例は法律です。一般的に法体系というのは巨大で、しばしばその中に矛盾するような、あるいは一貫していない条文があることが知られています。}
                +p{\todo{例を上げる}}
                +p{このような場合に「矛盾をはらんでいるからこの法体系は無意味だ」という結論にしてしまうと司法が立ち行かなくなってしまいます。代わりに行うべきことは、その部分が矛盾していることを認めた上で妥当な推論を重ねて結論を得ることです。これはまさに真矛盾主義が主張していることです。}
            >
            +subsection {自己言及のパラドックス} <
                +p{もう一つ真矛盾主義によってすごく綺麗に説明できる概念があります。\dfn{自己言及のパラドックス}と呼ばれるものなのです。
                \quote{(1) : (1)は偽である}
                こんな感じの文です。この文自体は\dfn{嘘つきのパラドックス}と呼ばれています。この文は真なのでしょうか、偽なのでしょうか。それぞれの場合で考えてみましょう。
                \listing{
                    * (1)が真 → (1)より「(1)は偽」なので(1)は偽
                    * (1)が偽 → (1)の「(1)は偽」に一致するので(1)は真
                }
                あらら、どっちにしても前提の反対の結論がでてきて矛盾が生じてしまいますね。これはよくない。この嘘つきのパラドックス、最初に言い出したのはエイブリデスという古代ギリシアの哲学者らしく大変由緒正しいパラドックスです。面白いのはその長い歴史にも関わらず、このパラドックスに対する広く認められた解答は未だに存在しないということです。}
                +p{解答の一つとしては「自己言及のパラドックスは文として成り立っていない」というものが考えられます。例えば集合論におけるラッセルのパラドックスも自己言及のパラドックスの一種ですが、その解答としての公理的集合論はこのようなパラドックスをそもそも記述できないようにすることで矛盾を回避していると言えます。}
                +p{真矛盾主義は嘘つきのパラドックスを含む自己言及のパラドックスに対しもう一つの解答を提供します。すなわち「(1)は真でありかつ偽である」という解釈です。(1)が真かつ偽であるとすれば、(1)は真なので「(1)は偽」となりますが実際に(1)は偽でもあります。一方(1)は偽なので「(1)は偽」に一致して(1)は真となりますが、(1)は真かつ偽なので問題ありません。屁理屈に聞こえるかもしれませんが、しかし辻褄は合っています。このように真矛盾主義は嘘つきのパラドックスを文として認めた上で、意味論の側で解答を与えているわけです。}
            >
            +subsection {古代インド哲学} <

            >
        >
        +section {First Degree Entailmentの意味論} <
            +p{このような真矛盾主義主義という考え方があって、それを形式的な論理体系に落としこみたいというのはごく自然な考えですよね。ここでは\dfn{First Degree Entailment}(FDE)\cite[`Belnap77`];という論理体系を紹介します。}
            +p{まず記号の定義をしていきましょう。FDEの命題${A, B, \ldots}は\dfn{原子命題}p、\dfn{否定}${\neg A}、\dfn{連言}${A \wedge B}、\dfn{選言}${A \vee B}から成ります。気持ちの説明をすると原子命題は何らかの知識の対象(「猫はかわいい」とか「パリはアメリカの首都だ」とか)を抽象化したもので${p, q, \ldots}と書き表します。否定${\neg A}は「Aではない」、連言${A \wedge B}は「AかつBである」、選言${A \vee B}は「AまたはBである」という意味に解釈できます。
            }
            +p{古典論理だと命題は真であるか偽であるかのどちらかですよね。FDEはこれを一般化してある命題が「真であるかどうか」と「偽であるかどうか」を独立した性質として解釈します。
            \definition ?:({原子命題の解釈}) {
                原子命題の\dfn{解釈}${\tilde}は原子命題と真偽値(${=\brace{0, 1}})の二項関係である。
            }
            ${p\tilde 1}は「pは真である」、${p\tilde 0}は「pは偽である」という意味になります。ここであるpにおいて${p\tilde 1}かつ${p\tilde 0}である、あるいは${p\tilde 1}でも${p\tilde 0}でもないという状況がありうるのがポイントです。この原子命題の解釈を一般の命題に拡張することができます。
            \definition ?:({命題の解釈}) {
                命題の解釈は命題と真偽値の二項関係である。原子命題の解釈${\tilde}が与えられた時、これを以下のように拡張して命題の解釈とする。
                \align[
                    ${|A \wedge B \tilde 1 | \iff A \tilde 1 \and B \tilde 1 |};
                    ${|A \wedge B \tilde 0 | \iff A \tilde 0 \or B \tilde 0 |};
                ];
                \align[
                    ${|A \vee B \tilde 1 | \iff A \tilde 1 \or B \tilde 1 |};
                    ${|A \vee B \tilde 0 | \iff A \tilde 0 \and B \tilde 0 |};
                ];
                \align[
                    ${| \neg A \tilde 1 | \iff A \tilde 0 |};
                    ${| \neg A \tilde 0 | \iff A \tilde 1 |};
                ];
            }
            この定義はそれぞれの命題が真のみか偽のみである場合には古典論理と同じふるまいをします。しかしそうでない状況の場合には面白い結果が得られます。}
            +p{例として排中律${A \vee \neg A}がどのように解釈されうるかを考えてみましょう。${A \tilde 0}でも${A \tilde 1}でもない時、${\neg}の定義より${\neg A \tilde 0}でも${\neg A \tilde 1}でもありません。次に${\vee}の定義より${A \vee \neg A \tilde 0}でも${A \vee \neg A \tilde 1}でもないことが言えます。逆に${A \tilde 0}かつ${A \tilde 1}であるような状況を考えると、${\neg}の定義より${\neg A \tilde 0}かつ${\neg A \tilde 1}で、さらに${\vee}の定義より${A \vee \neg A \tilde 0}かつ${A \vee \neg A \tilde 1}であることが導けます。これはFDEにおいて排中律が「真でない」あるいは「偽である」状況がありうることを意味しています。同様のことが無矛盾則${\neg A \wedge \neg A}でも成り立ちます。}
            +p{\todo{4値論理にもできるよみたいな話をしてもいいのかもしれない}}
        >
        +section{双シーケント計算による推論体系} <
            +p{先程の話はFDEの意味論の側の話でしが、FDEを論理体系として成立させるためにはその意味論に対応する推論体系も必要です。BelnapによるFDEの元論文\cite[`Belnap77`];でもそういった推論規則を提示していますが、この記事ではBochmanによるBiconsequence Relationを用いた推論体系\cite[`Bochman98`];を紹介します。}

            +subsection{双シーケント計算} <
                +p{\todo{Bochman's biconsequence reltaionは多値論理を扱うフレームワーク的なものでオーバーキルなのでFDEに関する部分だけを抜き出した双シーケント計算の体系を紹介することにする}Biconsequence Relationは基本的には古典論理のシーケント計算を拡張したものと考えて差し支えなさそうです\footnote{もう少し捕捉すると古典論理のシーケント計算を一般化したものらしいScott consequence relationを更に拡張したもののようです}。命題の有限集合を${a, b, \ldots}と表記することにしましょう。古典論理のシーケント計算では、
                \math-list(${| \seq{a}{b} |});
                というシーケントは「${a}の命題が全て真であれば${b}の命題うち少なくとも1つが真である」ことを主張するのでした。Biconsequent Relationでは以下のようにシーケント\footnote{元論文ではbisequentと呼んでいますがこの記事では単にシーケントと呼ぶことにします。}を表記します。
                \math-list(${| \biseq{a}{b}{c}{d} |});
                このシーケントは「${a}の全てが真で、かつ${b}の全てが偽である時に、${c}の少なくとも1つが真であるか、あるいは${d}の少なくとも一つは偽である」ことを主張します。真と偽が別々の性質になったのでシーケントが倍になったわけです。これは形式的には以下のように定義で表わされます。
                    \definition  ?:({妥当なシーケント}) {
                        あるシーケント${\biseq{a}{b}{c}{d}}がFDEの解釈${\tilde}に対して\dfn{妥当}であるとは、全ての${A \in a}について${A \tilde 1}かつ全ての${B \in b}について${B \tilde 0}である場合に、${C \tilde 1}であるような${C \in c}があるかあるいは${D \tilde 0}であるような${D \in d}があることである。
                    }
                }
                +p{biconsequent relationにおける構造規則も古典論理のシーケント計算の拡張となっています。具体的には以下のような構造規則があります。}
                +math(${
                        \proven!(
                            open DeriveDSL in
                            derive(${\biseq{a'}{b'}{c'}{d'}})
                            |> by ({(Monotonicity)})
                            |> from [
                                assume(${\biseq{a}{b}{c}{d}});
                                assume(${a \subseteq a', b \subseteq b', c \subseteq c', d \subseteq d'})
                            ]
                        )
                });
                +math(${
                    \proven!(
                        open DeriveDSL in
                        derive(${\biseq{A}{\void}{A}{\void}})
                        |> by ({(Positive Reflexivity)})
                    )
                });
                +math(${
                    \proven!(
                        open DeriveDSL in
                        derive(${\biseq{\void}{A}{\void}{A}})
                        |> by ({(Negative Reflexivity)})
                    )
                });
                +math(${
                    \proven!(
                        open DeriveDSL in
                        derive(${\biseq{a}{b}{c}{d}})
                        |> by ({(Positive Cut)})
                        |> from [
                            assume(${\biseq{a}{b}{A, c}{d}});
                            assume(${\biseq{A, a}{b}{c}{d}});
                        ]
                    )
                });
                +math(${
                    \proven!(
                        open DeriveDSL in
                        derive(${\biseq{a}{b}{c}{d}})
                        |> by ({(Negative Cut)})
                        |> from [
                            assume(${\biseq{a}{b}{c}{A, d}});
                            assume(${\biseq{a}{A, b}{c}{d}});
                        ]
                    )
                });
                +p{Monotonicityは弱化の規則ですね。交換と縮約の規則はありませんが、これは${a, b, \ldots}が有限の集合であるという条件に内包されています。また真の命題と偽の命題それぞれについてReflexivityとCutがあります。}   
            >
            +subsection {FDEの推論規則} <
                +p{次に論理結合子に関するルールを見ていきましょう。古典論理のシーケント計算ではそれぞれの論理結合子について右規則と左規則がありますが、例によってFDEの双シーケント計算ではそれぞれが真と偽の場合に分裂します。}
                +p{
                    ${\vee}に関する規則
                    \math-list(${
                    | \proven!(
                        open DeriveDSL in
                        derive(${\biseq{a, A \vee B}{b}{c}{d}})
                        |> by({(${\vee}PL)})
                        |> from [
                            assume(${\biseq{a, A}{b}{c}{d}});
                            assume(${\biseq{a, B}{b}{c}{d}})
                        ]
                    )
                    | \proven!(
                        open DeriveDSL in
                        derive(${\biseq{a}{b}{c, A \vee B}{d}})
                        |> by({(${\vee}PR)})
                        |> from [
                            assume(${\biseq{a}{b}{c, A, B}{d}})
                        ]
                    )
                    |});
                    \math-list(${
                    | \proven!(
                        open DeriveDSL in
                        derive(${\biseq{a}{b, A \vee B}{c}{d}})
                        |> by({(${\vee}NL)})
                        |> from [
                            assume(${\biseq{a}{b, A, B}{c}{d}})
                        ]
                    )
                    | \proven!(
                        open DeriveDSL in
                        derive(${\biseq{a}{b}{c}{d, A \vee B}})
                        |> by({(${\vee}NR)})
                        |> from [
                            assume(${\biseq{a}{b}{c}{d, A}});
                            assume(${\biseq{a}{b}{c}{d, B}})
                        ]
                    )
                    |});
                }
                +p{
                    ${\wedge}に関する規則
                    \math-list(${
                    | \proven!(
                        open DeriveDSL in
                        derive(${\biseq{a, A \wedge B}{b}{c}{d}})
                        |> by({(${\wedge}PL)})
                        |> from [
                            assume(${\biseq{a, A, B}{b}{c}{d}})
                        ]
                    )
                    | \proven!(
                        open DeriveDSL in
                        derive(${\biseq{a}{b}{c, A \wedge B}{d}})
                        |> by({(${\wedge}PR)})
                        |> from [
                            assume(${\biseq{a}{b}{c, A}{d}});
                            assume(${\biseq{a}{b}{c, B}{d}})
                        ]
                    )
                    |});
                    \math-list(${
                    | \proven!(
                        open DeriveDSL in
                        derive(${\biseq{a}{b, A \wedge B}{c}{d}})
                        |> by({(${\wedge}NL)})
                        |> from [
                            assume(${\biseq{a}{b, A}{c}{d}});
                            assume(${\biseq{a}{b, B}{c}{d}})
                        ]
                    )
                    | \proven!(
                        open DeriveDSL in
                        derive(${\biseq{a}{b}{c}{d, A \wedge B}})
                        |> by({(${\wedge}NR)})
                        |> from [
                            assume(${\biseq{a}{b}{c}{d, A, B}});
                        ]
                    )
                    |});
                }
                +p{
                   ${\neg} に関する規則
                   \math-list(${
                   | \proven!(
                       open DeriveDSL in
                       derive(${\biseq{a,\neg A}{b}{c}{d}})
                       |> by ({(${\neg}PL)})
                       |> from [
                           assume(${\biseq{a}{b, A}{c}{d}})
                       ])
                   | \proven!(
                       open DeriveDSL in
                       derive(${\biseq{a}{b}{c, \neg A}{d}})
                       |> by ({(${\neg}PR)})
                       |> from [
                           assume(${\biseq{a}{b}{c}{d, A}})
                       ])
                   |});
                   \math-list(${
                   | \proven!(
                       open DeriveDSL in
                       derive(${\biseq{a}{b,\neg A}{c}{d}})
                       |> by ({(${\neg}NL)})
                       |> from [
                           assume(${\biseq{a, A}{b}{c}{d}})
                       ])
                   | \proven!(
                       open DeriveDSL in
                       derive(${\biseq{a}{b}{c}{d, \neg A}})
                       |> by ({(${\neg}NR)})
                       |> from [
                           assume(${\biseq{a, A}{b}{c, A}{d}})
                       ])
                   |});
                }
            >
            +subsection {基本的な性質} <
                +p{\todo{カット除去、健全性、完全性とかの話にふれる(詳しくはかかない)}}
            >
            +subsection {} <
                +p{${\nbiseq{A}{A}{\void}{\void}}}
            >
        >
        +section {FDEに特有の論理結合子} <
            +p{これまで説明してきたFDEの体系は古典論理のそれを内包するようなものになっています。つまり意味論においては「全ての命題の解釈が古典的である、つまり真のみか偽のみである、ような場合にはFDEの論理結合子は古典論理のそれと同じ振舞いをする」ということができます。あるいは推論体系においては「古典論理で${\seq{a}{b}}である時にFDEで${\biseq{a}{}{b}{}}」
            それゆえFDEに特徴的な論理結合子を定義することができます。ここでは元論文より\dfn{local negation}と\dfn{L}を紹介します。}
            +p{local negation${\lneg A}は${\neg A}と同じく否定を意味する論理結合子です。${\lneg A}の解釈は以下の通りです。\todo{ntildeの説明をどっかに書く}
            \align[
                ${| \lneg A \tilde 1 | \iff A \ntilde 1 |};
                ${| \lneg A \tilde 0 | \iff A \ntilde 0 |};
            ];
            ${\neg A}が${A}の真と偽を入れ替えるのに対して、${\lneg A}は${A}の真と偽をそれぞれ裏返すような論理結合子になっています。ちなみに${\lneg}との対比で${\neg}のことを\dfn{switchng negation}と呼ぶことがあります\cite[`Bochman98`];。
            local negationは古典的にはswitching negationと同じ振舞いをするのでFDEに特有の論理結合子というのはあまり適切ではないでね。どちらかというと\emph{古典論理における否定がFDEではlocal negationとswitching negationに分裂する}というのが正確に言い方になります。双シーケント計算における規則は以下のようになります。
            \math-list(${
                   | \proven!(
                       open DeriveDSL in
                       derive(${\biseq{a,\lneg A}{b}{c}{d}})
                       |> by ({(${\lneg}PL)})
                       |> from [
                           assume(${\biseq{a}{b}{c, A}{d}})
                       ])
                   | \proven!(
                       open DeriveDSL in
                       derive(${\biseq{a}{b}{c, \lneg A}{d}})
                       |> by ({(${\lneg}PR)})
                       |> from [
                           assume(${\biseq{a, A}{b}{c}{d}})
                       ])
                   |});
                   \math-list(${
                   | \proven!(
                       open DeriveDSL in
                       derive(${\biseq{a}{b,\lneg A}{c}{d}})
                       |> by ({(${\lneg}NL)})
                       |> from [
                           assume(${\biseq{a}{b}{c}{d, A}})
                       ])
                   | \proven!(
                       open DeriveDSL in
                       derive(${\biseq{a}{b}{c}{d, \lneg A}})
                       |> by ({(${\lneg}NR)})
                       |> from [
                           assume(${\biseq{a}{b, A}{c, A}{d}})
                       ])
                   |});
            }
            +p{もう一つ紹介するのは${\L}演算子です。
            \align[
                ${| \L A \tilde 1 | \iff A \tilde 1 |};
                ${| \L A \tilde 0 | \iff A \ntilde 1 |};
            ];
            \math-list(${
            | \proven!(
                open DeriveDSL in
                derive(${\biseq{a, \L A}{b}{c}{d}})
                |> by ({(${\L}PL)})
                |> from [
                    assume(${\biseq{a, A}{b}{c}{d}})
                ])
            | \proven!(
                open DeriveDSL in
                derive(${\biseq{a}{b}{c, \L A}{d}})
                |> by ({(${\L}PR)})
                |> from [
                    assume(${\biseq{a, A}{b}{c, A}{d}})
                ])
            |});
            \math-list(${
            | \proven!(
                open DeriveDSL in
                derive(${\biseq{a}{b,\L A}{c}{d}})
                |> by ({(${\L}NL)})
                |> from [
                    assume(${\biseq{a}{b}{c, A}{d}})
                ])
            | \proven!(
                open DeriveDSL in
                derive(${\biseq{a}{b}{c}{d, \L A}})
                |> by ({(${\L}NR)})
                |> from [
                    assume(${\biseq{a, A}{b}{A}{d}})
                ])
            |});
            }
        >
    >
>
end
